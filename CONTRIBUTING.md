# Руководство по внесению изменений в проект

Этот документ описывает требования к оформлению кода и соглашения по именованию для инфраструктуры RabbitMQ в проекте **API-Service-Coordinator**. Следование этим рекомендациям обеспечивает читаемость, единообразие и легкость поддержки кода.

## Требования к оформлению кода

### 1. Общие принципы
- Код должен соответствовать стандартам **PEP 8** (руководство по стилю кода Python) и **PEP 257** (руководство по документации строк).
- Используйте читаемые и понятные имена переменных, функций и классов, отражающие их назначение.
- Пишите код, который легко масштабировать и поддерживать, избегая избыточной сложности.
- Каждый модуль, класс и функция должны содержать документацию (docstring) на русском языке, описывающую их назначение, параметры и возвращаемые значения.

### 2. Форматирование кода
- **Линтер**: Используйте `flake8` для проверки стиля кода.
- **Форматирование**: Применяйте `black` с длиной строки 88 символов для автоматического форматирования.
- **Импорты**:
  - Группируйте импорты в следующем порядке: стандартная библиотека, сторонние библиотеки, локальные модули.
  - Избегайте `from module import *`.
  - Используйте абсолютные импорты внутри проекта (например, `from app.src.core.logging import logger`).
- **Длина строки**: Максимум 120 символов (настройка `black`).
- **Пробелы**:
  - Используйте 4 пробела для отступов, избегайте табуляции.
  - Добавляйте пустую строку между логическими блоками кода (функции, классы и т.д.).
- **Комментарии**:
  - Используйте комментарии для объяснения сложной логики, но избегайте избыточных комментариев.
  - Комментарии должны быть на русском языке и начинаться с заглавной буквы.
- **Имена**:
  - Переменные и функции: `snake_case` (например, `get_queue_info`, `rabbitmq_client`).
  - Классы: `CamelCase` (например, `RabbitMQClient`).
  - Константы: `UPPER_SNAKE_CASE` (например, `DEFAULT_TIMEOUT`).

### 3. Структура проекта
- Следуйте текущей структуре проекта:
  ```
  app/
  ├── configs/         # Конфигурационные файлы и настройки
  ├── src/            # Основной исходный код
  │   ├── api/        # API-эндпоинты и зависимости
  │   ├── core/       # Общие утилиты (например, логирование)
  │   └── ...         # Другие модули
  ├── tests/          # Тесты
  └── main.py         # Точка входа приложения
  ```
- Каждый модуль должен быть самодостаточным и выполнять одну задачу (принцип единственной ответственности).
- Храните схемы Pydantic в `app/src/api/<module>/schemas.py`.
- Зависимости FastAPI (например, `get_rabbitmq_client`) помещайте в `app/src/api/<module>/deps.py`.

### 4. Документация
- **Docstrings**: Каждая функция, метод и класс должны иметь docstring на русском языке в стиле sphinx или reStructuredText.
  Пример:
  ```python
  async def get_queue_info(self, queue_name: str) -> QueueInfo:
        """
        Возвращает информацию о конкретной очереди.
        
        :param queue_name: Имя очереди
        :type queue_name: str
        :return: Информация об очереди
        :rtype: QueueInfo
        """
  ```
- Документируйте API-эндпоинты в `routers.py` с помощью docstring, описывающих их назначение, параметры и ответы.
- Обновляйте `README.md` при добавлении новых функций или изменении API.

### 5. Тестирование
- Пишите юнит-тесты для всех новых функций и эндпоинтов с использованием `pytest`.
- Тесты должны находиться в папке `tests/`, с названиями файлов в формате `test_<module>.py`.
- Используйте `TestClient` из FastAPI для тестирования эндпоинтов.
- Покрывайте тестами как успешные сценарии, так и обработку ошибок.

### 6. Обработка ошибок
- Используйте кастомные исключения из `app/src/api/error_handling.py` (например, `RabbitMQConnectionError`, `QueueNotFoundError`).
- Все ошибки должны возвращать стандартизированный JSON-ответ с полями `exception_case`, `message`, `detail_message`, `context` и `status_code`.
- Логируйте ошибки с помощью `logger` из `app/src/core/logging.py`.

## Соглашение по именованию в RabbitMQ

Для обеспечения консистентности и предсказуемости в инфраструктуре RabbitMQ применяются следующие правила именования ключей, очередей, обменников и привязок.

### 1. Общие принципы
- Имена должны быть **понятными**, **уникальными** и **отражать назначение**.
- Используйте **нижний регистр** и разделяйте слова символом подчеркивания `_`.
- Избегайте специальных символов, кроме `_` и `.`.
- Все имена должны начинаться с префикса, связанного с проектом (`iset_`), чтобы избежать конфликтов.

### 2. Имена очередей
- Формат: `iset_<service>_<entity>_<action>`
- Примеры:
  - `iset_auth_user_create` — очередь для создания пользователей в сервисе авторизации.
  - `iset_billing_payment_process` — очередь для обработки платежей в сервисе биллинга.
- Правила:
  - `<service>`: Название сервиса (например, `auth`, `billing`, `notification`).
  - `<entity>`: Сущность, с которой работает очередь (например, `user`, `payment`, `order`).
  - `<action>`: Действие (например, `create`, `update`, `delete`, `process`).
  - Длина имени не должна превышать 255 символов (ограничение RabbitMQ).

### 3. Имена обменников
- Формат: `iset_<service>_<type>`
- Примеры:
  - `iset_auth_direct` — прямой обменник для сервиса авторизации.
  - `iset_notification_fanout` — веерный обменник для уведомлений.
- Правила:
  - `<service>`: Название сервиса.
  - `<type>`: Тип обменника (`direct`, `fanout`, `topic`, `headers`).
  - Если обменник общий для нескольких сервисов, используйте `iset_common_<type>`.

### 4. Ключи маршрутизации (Routing Keys)
- Формат: `<service>.<entity>.<action>`
- Примеры:
  - `auth.user.create` — ключ для создания пользователя.
  - `billing.payment.process` — ключ для обработки платежа.
- Правила:
  - Используйте точки `.` для разделения компонентов.
  - Следуйте той же структуре, что и для очередей: `<service>.<entity>.<action>`.
  - Для topic-обменников можно использовать wildcards (`*` или `#`) в ключах маршрутизации, но только в конце (например, `auth.user.*`).

### 5. Привязки (Bindings)
- Привязки должны соответствовать ключам маршрутизации и именам очередей.
- Пример:
  - Очередь `iset_auth_user_create` привязывается к обменнику `iset_auth_direct` с ключом маршрутизации `auth.user.create`.
- Проверяйте, чтобы привязки были уникальными и не создавали конфликтов.

### 6. Конфигурация в `InfrastructureConfig`
- Пример конфигурации:
  ```python
  InfrastructureConfig(
      exchanges=[{"name": "iset_auth_direct", "type": "direct"}],
      queues=[{"name": "iset_auth_user_create"}],
      bindings=[{"exchange": "iset_auth_direct", "queue": "iset_auth_user_create", "routing_key": "auth.user.create"}],
      services_config=[]
  )
  ```
- Убедитесь, что имена в `InfrastructureConfig` соответствуют соглашениям выше.

### 7. Дополнительные рекомендации
- **Уникальность**: Проверяйте, что имена очередей и обменников уникальны в пределах виртуального хоста.
- **Документация**: В `InfrastructureConfig` добавляйте комментарии, описывающие назначение каждой очереди, обменника и ключа.
- **Очистка**: При удалении очередей или обменников документируйте изменения в конфигурации.
- **Тестирование**: Проверяйте конфигурацию в тестовой среде перед применением в продакшене.

## Процесс внесения изменений

1. **Создание ветки**:
   - Используйте описательные имена веток: `<тип>/<описание>` (например, `feature/add-queue-endpoint`, `bugfix/error-handling`).
   - Типы: `feature`, `bugfix`, `docs`, `refactor`.

2. **Коммиты**:
   - Пишите сообщения коммитов на русском языке в формате: `<тип>(<область>): <краткое описание>`.
   - Примеры:
     - `feat(rabbitmq): добавлен эндпоинт для получения информации об очереди`
     - `fix(error-handling): исправлена обработка исключений в client.py`
   - Типы: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `perf`.

3. **Пулл-реквесты**:
   - Создавайте Merge Request (MR) в GitLab с описанием изменений.
   - Указывайте, какие задачи решает MR (ссылка на issue, если есть).
   - Добавляйте ревьюеров из команды.
   - Убедитесь, что тесты проходят и линтер не выдает ошибок.

4. **Проверка кода**:
   - Перед отправкой MR выполните:
     ```bash
     flake8 .
     black --check .
     pytest
     ```
   - Исправьте все ошибки форматирования и линтера.

## Лицензия
Проект распространяется под лицензией MIT. Подробности см. в файле `LICENSE`.